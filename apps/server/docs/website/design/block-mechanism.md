# 文档块工作机制

本文档详细说明文档块（Block）的工作机制和实现细节，帮助理解块的生命周期、版本控制、排序和父子关系管理。

## 概述

文档块是文档内容的基本单元，每个块代表文档中的一个内容片段（如段落、标题、列表项等）。块以树形结构组织，通过父子关系形成文档的层次结构。

## 块的生命周期

### 1. 创建块

#### API 端点

```
POST /api/v1/blocks
```

#### 创建流程

1. **权限检查**：验证用户对文档的访问权限
2. **父块确定**：
   - 如果提供了 `parentId`，验证父块存在且属于同一文档
   - 如果**未提供 `parentId`**，自动设置为文档的**根块ID**
3. **排序键生成**：
   - 如果提供了 `sortKey`，直接使用
   - 如果未提供，自动生成：
     - 查询同级块（相同 `parentId`）的最新版本
     - 按 `sortKey` 排序，获取最后一个同级块的 `sortKey`
     - 生成比最后一个更大的 `sortKey`，确保新块出现在最后
4. **事务创建**：
   - 创建 `Block` 实体（元数据）
   - 创建 `BlockVersion` 实体（版本1，包含内容）
   - 根据 `createVersion` 参数决定是否立即创建文档版本

#### 创建示例

```json
// 请求体：不提供 parentId，自动挂到根块
{
  "docId": "doc_1234567890_abc123",
  "type": "paragraph",
  "payload": {
    "text": "这是新段落"
  },
  "createVersion": true
}

// 响应
{
  "blockId": "b_1234567890_def456",
  "docId": "doc_1234567890_abc123",
  "type": "paragraph",
  "version": 1,
  "payload": {
    "text": "这是新段落"
  }
}
```

#### 关键特性

- **默认挂到根块**：不提供 `parentId` 时，块会自动挂到文档的根块下
- **自动排序**：未提供 `sortKey` 时，自动生成排序键，新块出现在同级块的最后
- **版本控制**：创建时默认立即创建文档版本（`createVersion: true`）

### 2. 更新块内容

#### API 端点

```
POST /api/v1/blocks/:blockId/content
```

#### 更新流程

1. **验证块存在**：检查块是否存在且未被删除
2. **权限检查**：验证用户对文档的访问权限
3. **内容哈希检查**：如果内容未改变，直接返回当前版本
4. **保留位置信息**：
   - **保留 `parentId`**：更新内容时，块的父块关系不变
   - **保留 `sortKey`**：更新内容时，块的位置不变
   - **保留 `indent`**：保留缩进级别
   - **保留 `collapsed`**：保留折叠状态
5. **创建新版本**：
   - 创建新的 `BlockVersion`（版本号递增）
   - 更新 `Block.latestVer`、`latestAt`、`latestBy`
   - 根据 `createVersion` 参数决定是否立即创建文档版本

#### 更新示例

```json
// 请求体
{
  "payload": {
    "text": "更新后的内容"
  },
  "plainText": "更新后的内容",
  "createVersion": true
}
```

#### 关键特性

- **位置不变**：更新内容时，块的位置（`sortKey`）和父块关系（`parentId`）保持不变
- **版本递增**：每次更新都会创建新版本，保留历史记录
- **内容去重**：如果内容哈希未改变，不会创建新版本

### 3. 移动块

#### API 端点

```
PATCH /api/v1/blocks/:blockId/move
```

#### 移动流程

1. **验证块存在**：检查块是否存在且未被删除
2. **循环检测**：检查移动操作是否会导致循环引用（块不能成为自己的祖先）
3. **创建新版本**：
   - 更新 `parentId`、`sortKey`、`indent`
   - 保留 `payload`、`collapsed` 等其他属性
   - 创建新的 `BlockVersion`
4. **版本控制**：根据 `createVersion` 参数决定是否立即创建文档版本

#### 移动示例

```json
// 请求体
{
  "parentId": "b_1234567890_parent",
  "sortKey": "250000",
  "indent": 1,
  "createVersion": true
}
```

#### 关键特性

- **循环检测**：防止块成为自己的祖先，避免循环引用
- **位置精确控制**：可以精确指定新位置的 `sortKey` 和 `indent`

### 4. 删除块

#### API 端点

```
DELETE /api/v1/blocks/:blockId
```

#### 删除流程

1. **验证块存在**：检查块是否存在且未被删除
2. **权限检查**：验证用户对文档的访问权限
3. **软删除**：
   - 设置 `Block.isDeleted = true`
   - 设置 `Block.deletedAt`、`Block.deletedBy`
   - **不删除 `BlockVersion` 记录**：保留历史版本
4. **版本控制**：删除操作默认立即创建文档版本（重要操作）

#### 删除特性

- **软删除**：块被标记为删除，但数据仍保留在数据库中
- **历史保留**：删除后，块的历史版本仍然可以访问
- **树构建过滤**：获取文档内容时，已删除的块会被自动过滤

### 5. 批量操作

#### API 端点

```
POST /api/v1/blocks/batch
```

#### 支持的操作类型

- **create**：批量创建块
- **update**：批量更新块
- **delete**：批量删除块
- **move**：批量移动块

#### 批量操作特性

- **事务保证**：所有操作在同一个事务中执行，要么全部成功，要么全部回滚
- **统一版本控制**：可以统一控制是否创建文档版本
- **错误处理**：单个操作失败不影响其他操作，返回详细的结果列表

## 排序机制（sortKey）

### 排序键的作用

`sortKey` 用于确定块在同级块中的显示顺序。它是一个数字字符串，通过数字比较来确定顺序。

### 排序键生成规则

1. **默认值**：如果没有同级块，返回 `"500000"`（中间值）
2. **自动生成**：
   - 查询同级块（相同 `parentId`）的最新版本
   - 按 `sortKey` 数字排序
   - 获取最后一个同级块的 `sortKey`
   - 生成比最后一个更大的 `sortKey`
3. **分数排序系统**：
   - 使用 `generateSortKey(prevKey, nextKey)` 函数
   - 支持在任意位置插入新元素
   - 如果空间不足，会计算中间值

### 排序键比较

使用 `compareSortKey(a, b)` 函数进行数字比较：

- 将字符串转换为数字进行比较
- 返回负数表示 `a < b`
- 返回 0 表示 `a === b`
- 返回正数表示 `a > b`

### 排序稳定性

当多个块的 `sortKey` 相同时，使用 `blockId` 进行稳定排序，确保排序结果的一致性。

## 版本控制机制

### 块版本（BlockVersion）

每个块可以有多个版本，版本号从 1 开始递增。每个版本包含：

- `ver`：版本号
- `payload`：块内容
- `parentId`：父块ID（可能在不同版本中改变）
- `sortKey`：排序键（可能在不同版本中改变）
- `indent`：缩进级别
- `collapsed`：折叠状态
- `hash`：内容哈希值（用于去重）
- `plainText`：纯文本（用于搜索）
- `createdAt`：创建时间
- `createdBy`：创建者

### 文档版本（DocRevision）

文档版本记录了文档在某个时间点的完整状态：

- `docVer`：文档版本号
- `rootBlockId`：根块ID（用于快速定位）
- `createdAt`：创建时间
- `createdBy`：创建者
- `message`：版本消息

### 版本创建策略

1. **立即创建**（`createVersion: true`，默认）：
   - 操作完成后立即创建文档版本
   - 适用于重要操作（创建、删除、移动）

2. **延迟创建**（`createVersion: false`）：
   - 操作完成后不立即创建文档版本
   - 记录为"待创建版本"
   - 可以批量操作后统一创建版本

### 版本查询

- **获取特定版本**：`GET /api/v1/documents/:docId/content?version=5`
- **获取最新版本**：`GET /api/v1/documents/:docId/content`（不指定 version）

## 父子关系管理

### 父子关系的存储

父子关系存储在 `BlockVersion.parentId` 字段中：

- 根块的子块：`parentId = 根块的 blockId`
- 嵌套块：`parentId = 父块的 blockId`
- 根块本身：`parentId` 通常为空字符串（但根块不应该有父块）

### 树构建过程

获取文档内容时，系统会：

1. **获取文档版本**：确定要查询的文档版本号
2. **构建版本映射**：查询该版本下所有块的有效版本号
3. **过滤已删除块**：排除 `isDeleted = true` 的块
4. **构建树结构**：
   - 从根块开始
   - 递归查找 `parentId` 匹配的子块
   - 按 `sortKey` 排序子块
   - 构建完整的树结构

### 根块的特殊处理

1. **根块必须存在**：获取文档内容时，如果根块不存在或被删除，会返回明确的错误信息
2. **根块不会被删除**：虽然技术上可以删除根块，但不建议这样做
3. **根块在版本映射中**：确保根块始终包含在版本映射中

## 块类型（type）

块类型用于标识块的内容类型，常见类型包括：

- `root`：根块（特殊类型，每个文档只有一个）
- `paragraph`：段落
- `heading`：标题
- `list`：列表
- `code`：代码块
- 等等...

块类型不影响块的行为，主要用于前端渲染和内容解析。

## 块内容（payload）

`payload` 是块的实际内容，格式为 JSON 对象。不同块类型有不同的 `payload` 结构：

```json
// 段落块
{
  "text": "这是段落内容"
}

// 标题块
{
  "level": 1,
  "text": "这是标题"
}

// 列表块
{
  "type": "ordered",
  "items": ["项目1", "项目2"]
}
```

## 最佳实践

### 1. 创建块时

- **不提供 `parentId`**：让块自动挂到根块下，简化操作
- **不提供 `sortKey`**：让系统自动生成，确保新块出现在最后
- **使用 `createVersion: false`**：批量创建时，统一创建版本以提高性能

### 2. 更新块时

- **只更新 `payload`**：不要修改 `parentId` 或 `sortKey`（使用移动接口）
- **使用 `createVersion: false`**：频繁更新时，可以延迟创建版本

### 3. 移动块时

- **精确指定 `sortKey`**：使用分数排序系统计算合适的 `sortKey`
- **检查循环引用**：确保不会导致循环引用

### 4. 删除块时

- **谨慎删除根块**：删除根块会导致文档无法正常显示
- **批量删除**：使用批量操作接口提高效率

## 常见问题

### Q: 为什么更新块后，块的位置会改变？

A: 更新块内容时，系统会保留 `sortKey` 和 `parentId`，位置不应该改变。如果位置改变了，可能是：

1. 使用了错误的排序逻辑（已修复）
2. `sortKey` 为空或无效（系统会使用默认值 `"500000"`）

### Q: 删除块后，还能恢复吗？

A: 可以。删除是软删除，数据仍保留在数据库中。可以通过恢复接口（如果实现）或直接修改数据库来恢复。

### Q: 如何获取块的历史版本？

A: 使用 `GET /api/v1/blocks/:blockId/versions` 接口获取块的所有版本。

### Q: 批量操作时，如何控制版本创建？

A: 在批量操作请求中设置 `createVersion: false`，然后在操作完成后调用 `POST /api/v1/documents/:docId/commit` 统一创建版本。
